import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';
import html2canvas from 'html2canvas';

export interface ExportOptions {
  filename: string;
  title: string;
  includeCharts?: boolean;
  dateRange?: {
    from: Date | null;
    to: Date | null;
  };
}

export interface ExportData {
  headers: string[];
  rows: any[][];
  metadata?: {
    totalRecords: number;
    generatedAt: string;
    generatedBy: string;
    reportPeriod?: string;
  };
}

class ExportService {
  /**
   * Export data to CSV format
   */
  async exportToCSV(data: ExportData, options: ExportOptions): Promise<void> {
    try {
      let csvContent = '';
      
      // Add metadata header if available
      if (data.metadata) {
        csvContent += `"${options.title}"\n`;
        csvContent += `"Generated at: ${data.metadata.generatedAt}"\n`;
        csvContent += `"Generated by: ${data.metadata.generatedBy}"\n`;
        if (data.metadata.reportPeriod) {
          csvContent += `"Report Period: ${data.metadata.reportPeriod}"\n`;
        }
        csvContent += `"Total Records: ${data.metadata.totalRecords}"\n\n`;
      }
      
      // Add headers
      csvContent += data.headers.map(header => `"${header}"`).join(',') + '\n';
      
      // Add data rows
      data.rows.forEach(row => {
        const csvRow = row.map(cell => {
          // Handle different data types
          if (cell === null || cell === undefined) return '""';
          if (typeof cell === 'string') return `"${cell.replace(/"/g, '""')}"`;
          if (typeof cell === 'number') return cell.toString();
          if (cell instanceof Date) return `"${cell.toISOString()}"`;
          return `"${String(cell).replace(/"/g, '""')}"`;
        }).join(',');
        csvContent += csvRow + '\n';
      });

      // Create and download file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      saveAs(blob, `${options.filename}.csv`);
    } catch (error) {
      console.error('CSV export error:', error);
      throw new Error('Failed to export CSV file');
    }
  }

  /**
   * Export data to Excel format
   */
  async exportToExcel(data: ExportData, options: ExportOptions): Promise<void> {
    try {
      const workbook = XLSX.utils.book_new();
      
      // Create main data worksheet
      const worksheetData = [data.headers, ...data.rows];
      const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
      
      // Set column widths
      const colWidths = data.headers.map(() => ({ width: 20 }));
      worksheet['!cols'] = colWidths;
      
      // Add metadata sheet if available
      if (data.metadata) {
        const metadataSheet = XLSX.utils.aoa_to_sheet([
          ['Report Title', options.title],
          ['Generated At', data.metadata.generatedAt],
          ['Generated By', data.metadata.generatedBy],
          ['Total Records', data.metadata.totalRecords],
          ...(data.metadata.reportPeriod ? [['Report Period', data.metadata.reportPeriod]] : [])
        ]);
        XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Metadata');
      }
      
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Report Data');
      
      // Generate and download file
      const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([excelBuffer], { 
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
      });
      saveAs(blob, `${options.filename}.xlsx`);
    } catch (error) {
      console.error('Excel export error:', error);
      throw new Error('Failed to export Excel file');
    }
  }

  /**
   * Export data to PDF format with optional charts
   */
  async exportToPDF(data: ExportData, options: ExportOptions, chartElementId?: string): Promise<void> {
    try {
      const pdf = new jsPDF('portrait', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      let currentY = 20;
      const margin = 15;
      const lineHeight = 8;
      
      // Title
      pdf.setFontSize(18);
      pdf.setFont('helvetica', 'bold');
      pdf.text(options.title, margin, currentY);
      currentY += 15;
      
      // Metadata
      if (data.metadata) {
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        pdf.text(`Generated: ${data.metadata.generatedAt}`, margin, currentY);
        currentY += 5;
        pdf.text(`Generated by: ${data.metadata.generatedBy}`, margin, currentY);
        currentY += 5;
        if (data.metadata.reportPeriod) {
          pdf.text(`Report Period: ${data.metadata.reportPeriod}`, margin, currentY);
          currentY += 5;
        }
        pdf.text(`Total Records: ${data.metadata.totalRecords}`, margin, currentY);
        currentY += 10;
      }
      
      // Include charts if requested and element exists
      if (options.includeCharts && chartElementId) {
        const chartElement = document.getElementById(chartElementId);
        if (chartElement) {
          try {
            const canvas = await html2canvas(chartElement, {
              scale: 1,
              useCORS: true,
              allowTaint: true
            });
            
            const imgData = canvas.toDataURL('image/png');
            const imgWidth = pageWidth - (margin * 2);
            const imgHeight = (canvas.height * imgWidth) / canvas.width;
            
            // Check if we need a new page
            if (currentY + imgHeight > pageHeight - margin) {
              pdf.addPage();
              currentY = margin;
            }
            
            pdf.addImage(imgData, 'PNG', margin, currentY, imgWidth, imgHeight);
            currentY += imgHeight + 10;
          } catch (chartError) {
            console.warn('Failed to include chart in PDF:', chartError);
          }
        }
      }
      
      // Table data
      if (data.rows.length > 0) {
        // Check if we need a new page for the table
        if (currentY + (lineHeight * 3) > pageHeight - margin) {
          pdf.addPage();
          currentY = margin;
        }
        
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Data Report', margin, currentY);
        currentY += 10;
        
        // Headers
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'bold');
        const colWidth = (pageWidth - (margin * 2)) / data.headers.length;
        
        data.headers.forEach((header, index) => {
          const x = margin + (index * colWidth);
          pdf.text(String(header), x, currentY);
        });
        currentY += lineHeight;
        
        // Draw header line
        pdf.line(margin, currentY, pageWidth - margin, currentY);
        currentY += 3;
        
        // Data rows
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(8);
        
        data.rows.forEach((row) => {
          // Check if we need a new page
          if (currentY + lineHeight > pageHeight - margin) {
            pdf.addPage();
            currentY = margin;
            
            // Repeat headers on new page
            pdf.setFont('helvetica', 'bold');
            data.headers.forEach((header, index) => {
              const x = margin + (index * colWidth);
              pdf.text(String(header), x, currentY);
            });
            currentY += lineHeight;
            pdf.line(margin, currentY, pageWidth - margin, currentY);
            currentY += 3;
            pdf.setFont('helvetica', 'normal');
          }
          
          row.forEach((cell, index) => {
            const x = margin + (index * colWidth);
            let cellText = '';
            
            if (cell === null || cell === undefined) {
              cellText = '';
            } else if (typeof cell === 'string') {
              cellText = cell.length > 25 ? cell.substring(0, 22) + '...' : cell;
            } else if (typeof cell === 'number') {
              cellText = cell.toString();
            } else if (cell instanceof Date) {
              cellText = cell.toLocaleDateString();
            } else {
              cellText = String(cell);
            }
            
            pdf.text(cellText, x, currentY);
          });
          
          currentY += lineHeight;
        });
      }
      
      // Footer
      const totalPages = pdf.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'normal');
        pdf.text(
          `Page ${i} of ${totalPages}`,
          pageWidth - margin - 20,
          pageHeight - 10
        );
      }
      
      // Save the PDF
      pdf.save(`${options.filename}.pdf`);
    } catch (error) {
      console.error('PDF export error:', error);
      throw new Error('Failed to export PDF file');
    }
  }

  /**
   * Generate report metadata
   */
  generateMetadata(totalRecords: number, dateRange?: ExportOptions['dateRange']): ExportData['metadata'] {
    const now = new Date();
    let reportPeriod = '';
    
    if (dateRange?.from && dateRange?.to) {
      if (dateRange.from.getTime() === dateRange.to.getTime()) {
        reportPeriod = dateRange.from.toLocaleDateString();
      } else {
        reportPeriod = `${dateRange.from.toLocaleDateString()} to ${dateRange.to.toLocaleDateString()}`;
      }
    }
    
    return {
      totalRecords,
      generatedAt: now.toLocaleString(),
      generatedBy: 'Marketing Reports System',
      reportPeriod: reportPeriod || undefined
    };
  }

  /**
   * Format data for export
   */
  formatDataForExport(
    rawData: any[], 
    columns: { key: string; header: string; formatter?: (value: any) => string }[]
  ): ExportData {
    const headers = columns.map(col => col.header);
    const rows = rawData.map(item => 
      columns.map(col => {
        const value = item[col.key];
        return col.formatter ? col.formatter(value) : value;
      })
    );
    
    return { headers, rows };
  }
}

export default new ExportService();